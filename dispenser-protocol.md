# Token Dispenser HTTP Protocol

Stateless HTTP protocol for Raspberry Pi ↔ Wemos D1 communication.

**Wemos D1** = HTTP server (runs the dispenser hardware)
**Raspberry Pi** = HTTP client (POS terminal, drives the flow)

---

## Design Principles

1. **Idempotent by transaction ID** — every mutating request carries a client-generated `tx_id`. Repeating the same `tx_id` returns the cached result, never double-dispenses.
2. **Single-resource locking** — the dispenser is a single physical device. Only one transaction can be active. Concurrent requests get `409 Conflict`.
3. **Crash-safe** — the Wemos persists minimal state to flash (tx_id + dispensed count) so it survives power cycles mid-dispense. The Pi can always recover by polling.
4. **Timeout-based cleanup** — if the Pi disappears, the Wemos auto-cancels after a configurable timeout (default 30s).

## Transaction Model

The Pi is the **source of truth** for transactions. It stores them locally in SQLite and eventually syncs with the club backend. The Wemos knows nothing about members, accounts, or money — it only knows how to dispense N tokens for a given `tx_id`.

```
Pi local DB                    Wemos                     Backend (remote)
┌──────────────┐          ┌──────────────┐          ┌──────────────┐
│ transactions │          │  dispenser   │          │  club server │
│  - tx_id     │  HTTP    │  - tx_id     │          │              │
│  - member_id │─────────►│  - quantity  │          │              │
│  - quantity  │◄─────────│  - dispensed │          │              │
│  - dispensed │          │  - state     │          │              │
│  - state     │          └──────────────┘          │              │
│  - timestamp │                                    │              │
│  - synced    │ ·····················eventual······►│              │
└──────────────┘                sync                └──────────────┘
```

The Pi writes the transaction record **before** telling the Wemos to dispense. After dispensing completes (or fails), the Pi updates the record with the actual `dispensed` count. This local record is the audit trail — it captures exactly what happened regardless of whether the backend is reachable.

---

## Data Types

```
tx_id       := string, 8-16 hex chars, generated by Pi (e.g. "a3f8c012")
quantity    := integer, 1–20
token_state := "idle" | "reserved" | "dispensing" | "done" | "error"
```

---

## Endpoints

### `GET /health`

Heartbeat / connectivity check.

**Response `200 OK`**
```json
{
  "status": "ok",
  "uptime_s": 84230,
  "firmware": "1.2.0",
  "dispenser": "idle",
  "hopper_low": false
}
```

`hopper_low` = optical sensor indicates token supply is running low.

---

### `POST /dispense`

**The only mutating endpoint.** Drives a simple state machine via an `action` field.

All requests require `tx_id`. The Wemos uses this to deduplicate and correlate.

---

#### Action: `reserve`

Locks the dispenser for a future dispense. No tokens move yet.
This is the point where the Pi has confirmed payment but hasn't triggered hardware.

```json
POST /dispense
{
  "tx_id": "a3f8c012",
  "action": "reserve",
  "quantity": 3
}
```

**`200 OK`** — reserved successfully
```json
{
  "tx_id": "a3f8c012",
  "state": "reserved",
  "quantity": 3,
  "expires_in_s": 30
}
```

**`409 Conflict`** — another transaction is active
```json
{
  "error": "busy",
  "active_tx_id": "b7e1d904",
  "active_state": "dispensing"
}
```

**`422 Unprocessable`** — bad quantity, hopper empty, hardware fault
```json
{
  "error": "hopper_empty"
}
```

**Idempotency:** repeating the same `tx_id` + `reserve` returns the current state of that transaction (which may have progressed to `dispensing` or `done` if confirmed in between).

---

#### Action: `confirm`

Triggers the physical dispense. Only valid for a `reserved` transaction.

```json
POST /dispense
{
  "tx_id": "a3f8c012",
  "action": "confirm"
}
```

**`200 OK`** — dispensing started (or already finished)
```json
{
  "tx_id": "a3f8c012",
  "state": "dispensing",
  "quantity": 3,
  "dispensed": 0
}
```

Or if the dispense already completed (idempotent retry):
```json
{
  "tx_id": "a3f8c012",
  "state": "done",
  "quantity": 3,
  "dispensed": 3
}
```

**`404 Not Found`** — tx_id unknown (expired or never reserved)
```json
{
  "error": "unknown_tx",
  "tx_id": "a3f8c012"
}
```

**`409 Conflict`** — tx_id belongs to a cancelled transaction
```json
{
  "error": "tx_cancelled",
  "tx_id": "a3f8c012"
}
```

---

#### Action: `cancel`

Releases the reservation without dispensing. Only valid in `reserved` state.
Cannot cancel a transaction that's already `dispensing`.

```json
POST /dispense
{
  "tx_id": "a3f8c012",
  "action": "cancel"
}
```

**`200 OK`**
```json
{
  "tx_id": "a3f8c012",
  "state": "cancelled"
}
```

**`409 Conflict`** — already dispensing, too late to cancel
```json
{
  "error": "already_dispensing",
  "tx_id": "a3f8c012",
  "dispensed": 1
}
```

---

### `GET /dispense/{tx_id}`

Poll the status of a transaction. This is how the Pi tracks progress of an active dispense and how it recovers after a crash.

**`200 OK`**
```json
{
  "tx_id": "a3f8c012",
  "state": "dispensing",
  "quantity": 3,
  "dispensed": 2
}
```

The `dispensed` field increments in real-time as each token drops.

**`404 Not Found`** — tx_id unknown or expired from history

---

### `POST /dispense` (shorthand: reserve + confirm in one)

For simple flows where two round-trips aren't needed (e.g. quick single-token purchases where the Pi has already written the local transaction), the Pi can send `action: "dispense"` which atomically reserves and starts dispensing.

```json
POST /dispense
{
  "tx_id": "a3f8c012",
  "action": "dispense",
  "quantity": 3
}
```

Same responses as `confirm`, same idempotency guarantees.

---

## State Machine (per transaction)

### Why reserve → confirm?

There's no remote backend in the loop, so why not just dispense directly? The two-phase approach lets the Pi:

1. **Check hardware availability** before committing the transaction to the local DB — if the dispenser is busy or jammed, the member sees an error *before* a transaction is recorded.
2. **Bail out cleanly** if something goes wrong between writing the local transaction and triggering the motor (e.g. UI cancel, power event, member walked away).
3. **Guarantee the local DB record exists** before any tokens move — no orphaned dispenses with no matching transaction.

For simpler flows (coin-op mode, quick purchases), the combined `action: "dispense"` skips this and goes straight through.

```
            reserve          confirm            [mechanical]
  (idle) ──────────► reserved ──────────► dispensing ──────────► done
                        │                     │
                   cancel│                    │[jam/fault]
                        ▼                     ▼
                    cancelled               error
```

The Wemos tracks exactly **one** active transaction. Previous transactions are kept
in a small ring buffer (last 8) for idempotency checks and crash recovery.

---

## Timing & Timeouts

| Parameter             | Default | Description                                      |
|-----------------------|---------|--------------------------------------------------|
| `reservation_ttl`     | 30s     | Auto-cancel if `confirm` not received             |
| `dispense_timeout`    | 60s     | Max time for full dispense before declaring error  |
| `per_token_timeout`   | 5s      | Max time between successive token drops            |
| `history_ttl`         | 300s    | How long completed tx_ids stay in ring buffer      |

All configurable via `POST /config` (optional, for commissioning).

---

## Error Recovery Scenarios

### Pi crashes mid-transaction

1. Pi reboots, queries local DB for transactions with `state != complete`
2. `GET /dispense/{tx_id}` → gets current state from Wemos
3. If `done` → update local DB with final `dispensed` count, mark complete
4. If `dispensing` → keep polling until `done` or `error`
5. If `reserved` → either `confirm` or `cancel`
6. If `404` → reservation timed out; mark local tx as `expired`, start new tx if needed

### Wemos crashes mid-dispense

1. Wemos reboots, reads persisted `{tx_id, quantity, dispensed}` from flash
2. Enters `error` state with partial count
3. Pi polls, sees `error` with `dispensed: 2, quantity: 3`
4. Pi records partial dispense in local DB (`dispensed=2, state=partial`)
5. Backend reconciliation handles the discrepancy (refund, credit, or staff alert)

### Network timeout (Pi doesn't get response)

1. Pi retries same `tx_id` — idempotency guarantees safe replay
2. If `reserve` was lost → Wemos sees it as new, reserves
3. If `confirm` was lost but Wemos received it → returns current state
4. If response was lost → same, returns current state

### Hopper jam mid-dispense

1. Wemos detects no token drop within `per_token_timeout`
2. Transition to `error`:
```json
{
  "tx_id": "a3f8c012",
  "state": "error",
  "error": "jam",
  "quantity": 3,
  "dispensed": 2
}
```
3. Pi handles partial dispense: records `dispensed=2, state=partial` in local DB, shows error on display, flags for backend sync

---

## Typical Flow

```
Pi                                          Wemos D1
 │                                              │
 │  [Pi writes tx to local DB:                  │
 │   tx_id, member_id, qty, state=pending]      │
 │                                              │
 │  POST /dispense                              │
 │  {tx_id:"a3f8c012", action:"reserve", qty:3} │
 │─────────────────────────────────────────────►│
 │                                              │ locks dispenser
 │◄─────────────────────────────────────────────│
 │  200 {state:"reserved", expires_in_s:30}     │
 │                                              │
 │  [Pi updates local DB: state=reserved]       │
 │                                              │
 │  POST /dispense                              │
 │  {tx_id:"a3f8c012", action:"confirm"}        │
 │─────────────────────────────────────────────►│
 │                                              │ motor starts
 │◄─────────────────────────────────────────────│
 │  200 {state:"dispensing", dispensed:0}        │
 │                                              │
 │  GET /dispense/a3f8c012  (poll)              │
 │─────────────────────────────────────────────►│
 │◄─────────────────────────────────────────────│
 │  200 {state:"dispensing", dispensed:2}        │
 │                                              │
 │  GET /dispense/a3f8c012  (poll)              │
 │─────────────────────────────────────────────►│
 │◄─────────────────────────────────────────────│
 │  200 {state:"done", dispensed:3}             │
 │                                              │
 │  [Pi updates local DB:                       │
 │   state=complete, dispensed=3, synced=false]  │
 │                                              │
 │  [... eventually syncs to backend ...]       │
```

---

## Implementation Notes

### Wemos D1 (ESP8266)

- **Flash persistence**: write `{tx_id, quantity, dispensed}` to EEPROM/LittleFS only on state transitions (not per-token — minimize write cycles). On boot, check for incomplete tx.
- **Single-threaded**: use non-blocking motor control. The HTTP server runs in the main loop; dispense logic runs via state machine ticked each loop iteration.
- **Memory**: the ring buffer of 8 past tx_ids fits easily in RAM (~256 bytes).
- **Token counting**: use the Azkoyen's opto-sensor output pin as an interrupt to count dispensed tokens.

### Raspberry Pi

- **tx_id generation**: `hex(random 4 bytes)` or monotonic counter + device prefix.
- **Local DB**: SQLite table with `tx_id, member_id, quantity, dispensed, state, created_at, updated_at, synced`. Write the record *before* calling the Wemos; update it with the outcome after.
- **Sync**: background job pushes `synced=false` transactions to the backend when connectivity is available. Backend confirms receipt, Pi marks `synced=true`.
- **Partial dispenses**: stored with `state=partial` and exact `dispensed` count. Backend decides resolution policy (credit, retry, staff intervention).
- **Poll interval**: 250ms during `dispensing` state. Back off to 1s after 10 polls.
- **Timeout**: if `dispensing` for > 60s with no progress, treat as hardware fault.
